# MySQL ‚Üí PostgreSQL ÁßªË°åË©≥Á¥∞Ë®àÁîªÊõ∏

## ÁèæÂú®„ÅÆÁä∂Ê≥ÅÂàÜÊûê

### Áô∫Ë¶ã„Åï„Çå„ÅüMySQL‰æùÂ≠òÁÆáÊâÄ

#### 1. „Éá„Éº„Çø„Éô„Éº„Çπ„Çπ„Ç≠„Éº„Éû„ÅÆÂ§âÊõ¥ÁÇπ
```sql
-- ‰∏ª„Å™Â§âÊõ¥ÁÇπ
1. ENUMÂûã ‚Üí VARCHAR + CHECKÂà∂Á¥Ñ
2. AUTO_INCREMENT ‚Üí SERIAL
3. ON UPDATE CURRENT_TIMESTAMP ‚Üí PostgreSQL„ÅÆ„Éà„É™„Ç¨„Éº
4. TIMESTAMP ‚Üí TIMESTAMP WITH TIME ZONEÊé®Â•®
5. CHECKÂà∂Á¥Ñ„ÅÆË™øÊï¥
```

#### 2. „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Ç≥„Éº„Éâ„ÅÆÂ§âÊõ¥ÁÇπ
- **Êé•Á∂ö„É©„Ç§„Éñ„É©„É™**: `mysql2` ‚Üí `pg`
- **„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº**: `?` ‚Üí `$1, $2, ...`
- **Êó•ÊôÇ„Éï„Ç©„Éº„Éû„ÉÉ„Éà**: `mysqlDateTime` ‚Üí PostgreSQLÂΩ¢Âºè
- **INSERT ... ON DUPLICATE KEY UPDATE** ‚Üí **INSERT ... ON CONFLICT**

## Phase 1: PostgreSQL„Çπ„Ç≠„Éº„Éû‰ΩúÊàê

### 1.1 PostgreSQLÁî®„Çπ„Ç≠„Éº„Éû„Éï„Ç°„Ç§„É´‰ΩúÊàê

```sql
-- scripts/postgres-schema.sql

-- Users table
CREATE TABLE IF NOT EXISTS users (
    id VARCHAR(255) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL CHECK (role IN ('husband', 'wife')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Allocation ratios table  
CREATE TABLE IF NOT EXISTS allocation_ratios (
    id VARCHAR(255) PRIMARY KEY,
    husband_ratio DECIMAL(3,2) NOT NULL CHECK (husband_ratio >= 0 AND husband_ratio <= 1),
    wife_ratio DECIMAL(3,2) NOT NULL CHECK (wife_ratio >= 0 AND wife_ratio <= 1),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CHECK (ABS(husband_ratio + wife_ratio - 1.0) < 0.001)
);

-- Expenses table
CREATE TABLE IF NOT EXISTS expenses (
    id VARCHAR(255) PRIMARY KEY,
    description TEXT NOT NULL,
    amount INTEGER NOT NULL CHECK (amount > 0),
    payer_id VARCHAR(255) NOT NULL,
    expense_year INTEGER NOT NULL,
    expense_month INTEGER NOT NULL,
    custom_husband_ratio DECIMAL(3,2) NULL CHECK (custom_husband_ratio IS NULL OR (custom_husband_ratio >= 0 AND custom_husband_ratio <= 1)),
    custom_wife_ratio DECIMAL(3,2) NULL CHECK (custom_wife_ratio IS NULL OR (custom_wife_ratio >= 0 AND custom_wife_ratio <= 1)),
    uses_custom_ratio BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (payer_id) REFERENCES users(id) ON DELETE CASCADE,
    CHECK (expense_year >= 2020 AND expense_year <= 2099),
    CHECK (expense_month >= 1 AND expense_month <= 12),
    CHECK (uses_custom_ratio = FALSE OR (custom_husband_ratio IS NOT NULL AND custom_wife_ratio IS NOT NULL AND ABS(custom_husband_ratio + custom_wife_ratio - 1.0) < 0.001))
);

-- Settlements table
CREATE TABLE IF NOT EXISTS settlements (
    id VARCHAR(255) PRIMARY KEY,
    expense_id VARCHAR(255) NOT NULL,
    husband_amount INTEGER NOT NULL,
    wife_amount INTEGER NOT NULL,
    payer VARCHAR(20) NOT NULL CHECK (payer IN ('husband', 'wife')),
    receiver VARCHAR(20) NOT NULL CHECK (receiver IN ('husband', 'wife')),
    settlement_amount INTEGER NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'completed')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (expense_id) REFERENCES expenses(id) ON DELETE CASCADE
);

-- UPDATEÁî®„ÅÆ„Éà„É™„Ç¨„ÉºÈñ¢Êï∞
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- „Éà„É™„Ç¨„Éº„ÅÆË®≠ÂÆö
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_allocation_ratios_updated_at BEFORE UPDATE ON allocation_ratios FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_expenses_updated_at BEFORE UPDATE ON expenses FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_settlements_updated_at BEFORE UPDATE ON settlements FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

## Phase 2: „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Ç≥„Éº„ÉâÂ§âÊõ¥

### 2.1 „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö„ÅÆÂ§âÊõ¥

```typescript
// backend/src/database/connection-postgres.ts
import { Pool, PoolConfig } from 'pg';
import path from 'path';
import fs from 'fs';

const dbConfig: PoolConfig = {
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
};

export const pool = new Pool(dbConfig);

export async function testConnection(): Promise<boolean> {
  try {
    const client = await pool.connect();
    await client.query('SELECT NOW()');
    client.release();
    console.log('Connected to PostgreSQL database');
    return true;
  } catch (error) {
    console.error('Failed to connect to PostgreSQL database:', error);
    return false;
  }
}

export async function initializeDatabase(): Promise<void> {
  try {
    const schemaPath = path.join(__dirname, 'postgres-schema.sql');
    const schema = fs.readFileSync(schemaPath, 'utf8');
    await pool.query(schema);
    console.log('Database schema initialized successfully');
  } catch (error) {
    console.error('Failed to initialize database schema:', error);
    throw error;
  }
}
```

### 2.2 „Çµ„Éº„Éì„ÇπÂ±§„ÅÆÂ§âÊõ¥

#### AllocationRatioServiceÂ§âÊõ¥
```typescript
// backend/src/services/allocationRatioService-postgres.ts
import { pool } from '../database/connection-postgres';

export const allocationRatioService = {
  async create(data: CreateAllocationRatioInput): Promise<AllocationRatio> {
    const id = generateId();
    
    const insertQuery = `
      INSERT INTO allocation_ratios (id, husband_ratio, wife_ratio, created_at, updated_at)
      VALUES ($1, $2, $3, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
    `;
    
    await pool.query(insertQuery, [id, data.husbandRatio, data.wifeRatio]);
    
    const selectQuery = 'SELECT * FROM allocation_ratios WHERE id = $1';
    const result = await pool.query(selectQuery, [id]);
    
    return result.rows[0];
  }
};
```

#### ExpenseServiceÂ§âÊõ¥  
```typescript
// backend/src/services/expenseService-postgres.ts
import { pool } from '../database/connection-postgres';

export class ExpenseService {
  async create(data: CreateExpenseInput): Promise<Expense> {
    const id = generateId();
    
    const insertQuery = `
      INSERT INTO expenses (
        id, description, amount, payer_id, expense_year, expense_month,
        custom_husband_ratio, custom_wife_ratio, uses_custom_ratio,
        created_at, updated_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
      )
    `;
    
    await pool.query(insertQuery, [
      id, data.description, data.amount, data.payerId,
      data.expenseYear, data.expenseMonth,
      data.customHusbandRatio, data.customWifeRatio, data.usesCustomRatio
    ]);
    
    const selectQuery = 'SELECT * FROM expenses WHERE id = $1';
    const result = await pool.query(selectQuery, [id]);
    
    return result.rows[0];
  }

  async updateOrCreate(id: string, data: UpdateExpenseInput): Promise<Expense> {
    // PostgreSQL„Åß„ÅÆINSERT ... ON CONFLICT
    const upsertQuery = `
      INSERT INTO expenses (
        id, description, amount, payer_id, expense_year, expense_month,
        custom_husband_ratio, custom_wife_ratio, uses_custom_ratio,
        created_at, updated_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
      )
      ON CONFLICT (id) DO UPDATE SET
        description = EXCLUDED.description,
        amount = EXCLUDED.amount,
        payer_id = EXCLUDED.payer_id,
        expense_year = EXCLUDED.expense_year,
        expense_month = EXCLUDED.expense_month,
        custom_husband_ratio = EXCLUDED.custom_husband_ratio,
        custom_wife_ratio = EXCLUDED.custom_wife_ratio,
        uses_custom_ratio = EXCLUDED.uses_custom_ratio,
        updated_at = CURRENT_TIMESTAMP
    `;
    
    await pool.query(upsertQuery, [
      id, data.description, data.amount, data.payerId,
      data.expenseYear, data.expenseMonth,
      data.customHusbandRatio, data.customWifeRatio, data.usesCustomRatio
    ]);
    
    const selectQuery = 'SELECT * FROM expenses WHERE id = $1';
    const result = await pool.query(selectQuery, [id]);
    
    return result.rows[0];
  }
}
```

### 2.3 package.json‰æùÂ≠òÈñ¢‰øÇ„ÅÆÊõ¥Êñ∞

```json
{
  "dependencies": {
    "pg": "^8.11.3",
    "@types/pg": "^8.10.9"
  }
}
```

## Phase 3: „Éá„Éº„ÇøÁßªË°å„Çπ„ÇØ„É™„Éó„Éà

### 3.1 ÁßªË°å„Çπ„ÇØ„É™„Éó„Éà‰ΩúÊàê

```bash
#!/bin/bash
# scripts/migrate-to-postgres.sh

set -e

echo "üöÄ Starting MySQL to PostgreSQL migration..."

# Áí∞Â¢ÉÂ§âÊï∞„ÅÆÁ¢∫Ë™ç
if [[ -z "$MYSQL_HOST" || -z "$MYSQL_USER" || -z "$MYSQL_PASSWORD" || -z "$POSTGRES_URL" ]]; then
    echo "‚ùå Required environment variables are missing"
    echo "Required: MYSQL_HOST, MYSQL_USER, MYSQL_PASSWORD, POSTGRES_URL"
    exit 1
fi

# ‰∏ÄÊôÇ„Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
TEMP_DIR=$(mktemp -d)
cd $TEMP_DIR

echo "üì¶ Exporting data from MySQL..."

# MySQL„Åã„Çâ„Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà
mysqldump --host=$MYSQL_HOST --user=$MYSQL_USER --password=$MYSQL_PASSWORD \
  --no-create-info --skip-triggers --single-transaction --lock-tables=false \
  --complete-insert --hex-blob --routines=false --events=false \
  splitmate > mysql_data.sql

echo "üîÑ Converting data format..."

# PostgreSQLÂΩ¢Âºè„Å´Â§âÊèõ
sed -i 's/`//g' mysql_data.sql
sed -i "s/\\\'/\'\'/g" mysql_data.sql
sed -i 's/\\n/\n/g' mysql_data.sql
sed -i 's/\\r/\r/g' mysql_data.sql

# ENUM„ÅÆÂ§âÊèõ
sed -i "s/'husband'/'husband'/g" mysql_data.sql
sed -i "s/'wife'/'wife'/g" mysql_data.sql
sed -i "s/'pending'/'pending'/g" mysql_data.sql
sed -i "s/'approved'/'approved'/g" mysql_data.sql
sed -i "s/'completed'/'completed'/g" mysql_data.sql

echo "üóÑÔ∏è Creating PostgreSQL schema..."
psql $POSTGRES_URL < /path/to/scripts/postgres-schema.sql

echo "üìä Importing data to PostgreSQL..."
psql $POSTGRES_URL < mysql_data.sql

echo "‚úÖ Migration completed successfully!"

# „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
cd -
rm -rf $TEMP_DIR
```

## Phase 4: „ÉÜ„Çπ„Éà„ÉªÊ§úË®º

### 4.1 „Éá„Éº„ÇøÊï¥ÂêàÊÄßÊ§úË®º

```sql
-- scripts/verify-migration.sql

-- „É¨„Ç≥„Éº„ÉâÊï∞„ÅÆÁ¢∫Ë™ç
SELECT 'users' as table_name, COUNT(*) as record_count FROM users
UNION ALL
SELECT 'allocation_ratios', COUNT(*) FROM allocation_ratios
UNION ALL
SELECT 'expenses', COUNT(*) FROM expenses  
UNION ALL
SELECT 'settlements', COUNT(*) FROM settlements;

-- „Éá„Éº„ÇøÂûã„ÅÆÁ¢∫Ë™ç
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name IN ('users', 'allocation_ratios', 'expenses', 'settlements')
ORDER BY table_name, ordinal_position;

-- Âà∂Á¥Ñ„ÅÆÁ¢∫Ë™ç
SELECT conname, contype, confrelid::regclass as referenced_table
FROM pg_constraint 
WHERE conrelid IN (
  SELECT oid FROM pg_class WHERE relname IN ('users', 'allocation_ratios', 'expenses', 'settlements')
);
```

### 4.2 „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà

```typescript
// tests/postgres-migration.test.ts
describe('PostgreSQL Migration Tests', () => {
  test('Database connection works', async () => {
    const result = await testConnection();
    expect(result).toBe(true);
  });

  test('Can create and retrieve allocation ratio', async () => {
    const data = { husbandRatio: 0.6, wifeRatio: 0.4 };
    const ratio = await allocationRatioService.create(data);
    expect(ratio.husband_ratio).toBe(0.6);
    expect(ratio.wife_ratio).toBe(0.4);
  });

  test('Can create and retrieve expense', async () => {
    const data = {
      description: 'Test expense',
      amount: 1000,
      payerId: 'user1',
      expenseYear: 2024,
      expenseMonth: 1
    };
    const expense = await expenseService.create(data);
    expect(expense.description).toBe('Test expense');
    expect(expense.amount).toBe(1000);
  });
});
```

## ÂÆüË£ÖÈ†ÜÂ∫è

1. ‚úÖ **Áí∞Â¢ÉÂàÜÊûêÂÆå‰∫Ü** - ÁèæÂú®„ÅÆMySQL„Çπ„Ç≠„Éº„Éû„Éª„Ç≥„Éº„ÉâÂàÜÊûê
2. üîÑ **PostgreSQL„Çπ„Ç≠„Éº„Éû‰ΩúÊàê** - Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó
3. ‚è≥ **Êé•Á∂ö„É©„Ç§„Éñ„É©„É™Â§âÊõ¥**
4. ‚è≥ **„Çµ„Éº„Éì„ÇπÂ±§PostgreSQLÂØæÂøú**
5. ‚è≥ **ÁßªË°å„Çπ„ÇØ„É™„Éó„Éà‰ΩúÊàê„Éª„ÉÜ„Çπ„Éà**
6. ‚è≥ **SupabaseÁí∞Â¢ÉÊßãÁØâ**
7. ‚è≥ **„Éá„Éº„ÇøÁßªË°åÂÆüË°å**
8. ‚è≥ **„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà**

## Ê¨°„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥

1. **PostgreSQL„Çπ„Ç≠„Éº„Éû„Éï„Ç°„Ç§„É´‰ΩúÊàê**: `scripts/postgres-schema.sql`
2. **„Éë„ÉÉ„Ç±„Éº„Ç∏‰æùÂ≠òÈñ¢‰øÇÊõ¥Êñ∞**: `pg`„É©„Ç§„Éñ„É©„É™ËøΩÂä†
3. **Êé•Á∂ö„É¢„Ç∏„É•„Éº„É´‰ΩúÊàê**: `connection-postgres.ts`
4. **ÊÆµÈöéÁöÑ„Çµ„Éº„Éì„ÇπÁßªË°å**: ÂêÑ„Çµ„Éº„Éì„Çπ„ÅÆPostgreSQLÂØæÂøúÁâà‰ΩúÊàê

„Åì„ÅÆË®àÁîª„Å´Âæì„Å£„Å¶ÂÆâÂÖ®„Å´ÁßªË°å„ÇíÈÄ≤„ÇÅ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ 
